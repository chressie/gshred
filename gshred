#!/usr/bin/env python

import re
import os
import sys
import shlex
import string
import traceback
import subprocess
import multiprocessing
import Tkinter as tk


class ShredException(Exception):
  pass

class Shred:

  EXE = '/usr/bin/shred'
  TERMINATED = '[TERMINATED]'

  def __init__(self):
    self._exact = True
    self._path = None
    self._zero = False
    self._iterations = 3

  def exact(self, value=True):
    self._exact = value
    return self

  def path(self, value):
    self._path = value
    return self

  def __call__(self, output):
    # Make sure that the path exists.
    if not self._path or not os.path.exists(self._path):
      raise ShredException('Could not find path "%s".' % self._path)

    # Build command line.
    command = '%s --force' % Shred.EXE
    command += ' --iterations=%d' % self._iterations
    if self._zero:
      command += ' --zero'
    if self._exact:
      command += ' --exact'
    if output:
      command += ' --verbose'
    command += ' %s' % self._path

    # Launch shred.
    print('Command: %s' % command)
    proc = subprocess.Popen(shlex.split(command),
                            shell=False,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            bufsize=0)
 
    # Get the verbose logging output (it's coming from stderr).
    while True:
      line = proc.stderr.readline()
      if not line:
        break
      output.put(line)
    
    # Notify termination status.
    proc.wait()
    output.put('%s %d' % (Shred.TERMINATED, proc.returncode)) 

  @staticmethod
  def launch(pool, shred):
    manager = multiprocessing.Manager()
    output = manager.Queue()
    return pool.apply_async(shred, (output,)), manager, output

class App:

  PULSE_PERIOD = 500

  def __init__(self):
    self._root = tk.Tk()
    self._create_layout()
    self._log.insert(tk.END, "HELLO")
    self._device = None

  def _create_layout(self):
    # Configure root element.
    self._root.resizable(width=False, height=False)
    self._root.grid_columnconfigure(0, weight=1)
    self._root.grid_rowconfigure(0, weight=1)

    # Create frame for the log.
    self._logframe = tk.Frame(self._root)
    self._logframe.grid(row=1, column=0, sticky='wens')

    # Create menu frame.
    self._menuframe = tk.Frame(self._root)
    self._menuframe.grid(row=0, column=0, sticky='wens')
    self._menuframe.grid_columnconfigure(0, weight=1)

    # Create textbox for the log output. Make it scrollable.
    self._log = tk.Text(self._logframe, height=10, width=80)
    self._scroll = tk.Scrollbar(self._logframe)
    self._scroll.pack(side=tk.RIGHT, fill=tk.Y)
    self._log.pack(side=tk.LEFT, fill=tk.BOTH)
    self._scroll.config(command=self._log.yview)
    self._log.config(yscrollcommand=self._scroll.set)

    # This is a hack to make the 'Text' widget readonly.
    # Source: http://stackoverflow.com/a/34811313
    self._log.bind("<Key>", lambda e: "break")

    # Create dropdown list of all devices (will be populated later).
    self._text = tk.StringVar(self._menuframe, "Chose device")
    devs = ('hello', 'world', '/dev/sdb')
    self._devices = tk.OptionMenu(self._menuframe, self._text, 
                                 *devs, command=self._selection)
    self._devices.grid(row=0, column=0, sticky='we')

    # Create shred button.
    self._button = tk.Button(self._menuframe, text="Shred!",
                             command=self._shred)
    self._button.grid(row=0, column=1)

  def _pulse(self):
    print('Pulse..')
    self._root.after(App.PULSE_PERIOD, self._pulse)

  def _selection(self, value):
    self._device = value
    print(self._device)

  def _shred(self):
    # Grab the device to be shredded.
    print('Shred!')

  def _refresh_devices(self):
    pass
    

  def run(self):
    self._root.after(App.PULSE_PERIOD, self._pulse)
    tk.mainloop()
    



def main():
  app = App()
  app.run()


  return
  shred = Shred().exact().path('/home/user/dev/gshred/testfile')
  pool = multiprocessing.Pool()
  result, manager, output = Shred.launch(pool, shred)
  timeouts = 0

  # Grab 
  while True:
    if timeouts > 3:
      print('Timed out')
      break
    try:
      # Only attempt this a couple of times before we give up.
      line = output.get(block=True, timeout=10.0).strip()
    except:
      timeouts += 1
      continue

    # We got an update, everything seems fine. Reset timeouts count.
    timeouts = 0
    if not line.startswith(Shred.TERMINATED):
      print(line)
    else:
      code = int(re.search(r'] (\d+)', line).group(1))
      print('Exit code: %d' % code)
      break

    if result.ready():
      print('Done')
      break

if __name__ == '__main__':
  main()

