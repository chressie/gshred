#!/usr/bin/env python

import re
import os
import sys
import shlex
import string
import traceback
import subprocess
import multiprocessing

import Tkinter


class ShredException(Exception):
  pass

class Shred:

  EXE = '/usr/bin/shred'
  TERMINATED = '[TERMINATED]'

  def __init__(self):
    self._exact = True
    self._path = None
    self._zero = False
    self._iterations = 3

  def exact(self, value=True):
    self._exact = value
    return self

  def path(self, value):
    self._path = value
    return self

  def __call__(self, output):
    assert output
    # Make sure that the path exists.
    if not self._path or not os.path.exists(self._path):
      raise ShredException('Could not find path "%s".' % self._path)

    # Build command line.
    command = '%s --force' % Shred.EXE
    command += ' --iterations=%d' % self._iterations
    if self._zero:
      command += ' --zero'
    if self._exact:
      command += ' --exact'
    if output:
      command += ' --verbose'
    command += ' %s' % self._path

    # Launch shred.
    print('Command: %s' % command)
    proc = subprocess.Popen(shlex.split(command),
                            shell=False,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            bufsize=0)
 
    # Get the verbose logging output (it's coming from stderr).
    while True:
      line = proc.stderr.readline()
      if not line:
        break
      output.put(line)
    
    # Notify termination status.
    proc.wait()
    output.put('%s %d' % (Shred.TERMINATED, proc.returncode)) 

  @staticmethod
  def launch(pool, shred):
    manager = multiprocessing.Manager()
    output = manager.Queue()
    return pool.apply_async(shred, (output,)), manager, output

def main():
  shred = Shred().exact().path('/home/user/dev/gshred/testfile')
  pool = multiprocessing.Pool()
  result, manager, output = Shred.launch(pool, shred)
  timeouts = 0

  # Grab 
  while True:
    if timeouts > 3:
      print('Timed out')
      break
    try:
      # Only attempt this a couple of times before we give up.
      line = output.get(block=True, timeout=10.0).strip()
    except:
      timeouts += 1
      continue

    # We got an update, everything seems fine. Reset timeouts count.
    timeouts = 0
    if not line.startswith(Shred.TERMINATED):
      print(line)
    else:
      code = int(re.search(r'] (\d+)', line).group(1))
      print('Exit code: %d' % code)
      break

    if result.ready():
      print('Done')
      break

if __name__ == '__main__':
  main()

